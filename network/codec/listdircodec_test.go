package codec_test

import (
	"bytes"
	"encoding/binary"
	"encoding/json"
	"go-networking/network/codec"
	"io"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestListDirHeader_Encode_ShouldReturnBytes_WhenGivenValidHeader(t *testing.T) {
	header := codec.ListDirHeader{
		Id:        "0123456789ABCDEF0123456789ABCDEF",
		Timestamp: time.Now().Unix(),
	}
	encoded, err := header.Encode()
	assert.NoError(t, err)
	assert.Len(t, encoded, 40)
}

func TestListDirHeader_Encode_ShouldReturnError_WhenIdIsInvalidLength(t *testing.T) {
	header := codec.ListDirHeader{
		Id:        "12345",
		Timestamp: time.Now().Unix(),
	}
	_, err := header.Encode()
	assert.Error(t, err)
}

func TestListDirHeader_Decode_ShouldReturnHeader_WhenGivenValidBytes(t *testing.T) {
	// Prepare input bytes
	timestamp := time.Now().Unix()
	id := "0123456789ABCDEF0123456789ABCDEF"
	data := append([]byte(id), make([]byte, 8)...)
	binary.BigEndian.PutUint64(data[32:], uint64(timestamp))

	header := codec.ListDirHeader{}
	err := header.Decode(data)
	assert.NoError(t, err)
	assert.Equal(t, id, header.Id)
	assert.Equal(t, timestamp, header.Timestamp)
}

func TestListDirHeader_Decode_ShouldReturnError_WhenGivenInvalidBytes(t *testing.T) {
	header := codec.ListDirHeader{}
	err := header.Decode([]byte{})
	assert.Error(t, err)
}

func TestListDirPayload_Encode_ShouldReturnBytes_WhenGivenValidPayload(t *testing.T) {
	payload := codec.ListDirPayload{
		DirPath: "/tmp/test",
	}
	encoded, err := payload.Encode()
	assert.NoError(t, err)
	// Check if the first two bytes represent the length correctly
	length := binary.BigEndian.Uint16(encoded)
	assert.Equal(t, uint16(len(payload.DirPath)), length)
}

func TestListDirPayload_Decode_ShouldReturnPayload_WhenGivenValidBytes(t *testing.T) {
	// Prepare input bytes similar to what's generated by Encode()
	dirPath := "/tmp/test"
	expectedPayload := codec.ListDirPayload{DirPath: dirPath}
	buf := new(bytes.Buffer)
	err := WriteLVString(buf, dirPath)
	require.NoError(t, err)
	data := buf.Bytes()

	payload := codec.ListDirPayload{}
	err = payload.Decode(data)
	assert.NoError(t, err)
	assert.Equal(t, expectedPayload, payload)
}

func WriteLVString(writer io.Writer, data string) error {
	if err := binary.Write(writer, binary.BigEndian, uint16(len(data))); err != nil {
		return err
	}
	_, err := writer.Write([]byte(data))
	return err
}

func TestListDirAckHeader_Encode_ShouldReturnBytes_WhenGivenValidHeader(t *testing.T) {
	header := codec.ListDirAckHeader{
		StatusCode: 200,
	}
	encoded, err := header.Encode()
	assert.NoError(t, err)
	assert.Len(t, encoded, 2)
}

func TestListDirAckHeader_Decode_ShouldReturnHeader_WhenGivenValidBytes(t *testing.T) {
	data := make([]byte, 2)
	binary.BigEndian.PutUint16(data, 200)

	header := codec.ListDirAckHeader{}
	err := header.Decode(data)
	assert.NoError(t, err)
	assert.Equal(t, uint16(200), header.StatusCode)
}

func TestListDirAckHeader_Decode_ShouldReturnError_WhenGivenInvalidBytes(t *testing.T) {
	data := make([]byte, 1) // only 1 byte, should be 2

	header := codec.ListDirAckHeader{}
	err := header.Decode(data)
	assert.Error(t, err)
}

func TestListDirAckPayload_Encode_ShouldReturnBytes_WhenGivenValidPayload(t *testing.T) {
	payload := codec.ListDirAckPayload{
		Files: []string{"file1.txt", "file2.txt"},
	}
	encoded, err := payload.Encode()
	assert.NoError(t, err)

	// Check if the first two bytes represent the length correctly
	var length uint16
	err = binary.Read(bytes.NewReader(encoded), binary.BigEndian, &length)
	assert.NoError(t, err)
	assert.Equal(t, uint16(len(encoded[2:])), length)
}

func TestListDirAckPayload_Decode_ShouldReturnPayload_WhenGivenValidBytes(t *testing.T) {
	files := []string{"file1.txt", "file2.txt"}
	jsonData, err := json.Marshal(files)
	require.NoError(t, err)

	buf := new(bytes.Buffer)
	WriteLVString(buf, string(jsonData))
	data := buf.Bytes()

	payload := codec.ListDirAckPayload{}
	err = payload.Decode(data)
	assert.NoError(t, err)
	assert.Equal(t, files, payload.Files)
}

func TestListDirAckPayload_Decode_ShouldReturnError_WhenGivenInvalidBytes(t *testing.T) {
	data := []byte{0, 1, '{'}

	payload := codec.ListDirAckPayload{}
	err := payload.Decode(data)
	assert.Error(t, err)
}
